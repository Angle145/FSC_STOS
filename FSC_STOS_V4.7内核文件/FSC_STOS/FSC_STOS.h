/*--------------------------------------------版本: V4.7--------------------------------------------*/
#ifndef _FSC_STOS_H_
#define _FSC_STOS_H_

/*****************头文件选择*****************/
//#include "stm32l0xx.h"  //stm32l0  STD库
//#include "stm32l1xx.h"  //stm32l1  STD库

//#include "stm32f0xx_hal.h"//stm32f0  HAL库
//#include "stm32f0xx.h"  //stm32f0  STD库
//#include "stm32f1xx_hal.h"//stm32f1  HAL库
#include "stm32f10x.h"  //stm32f1  STD库
//#include "stm32f4xx_hal.h"//stm32f4  HAL库
//#include "stm32f4xx.h"  //stm32f4  STD库
//#include "stm32f7xx_hal.h"//stm32f7  HAL库
/********************************************/
      
/****************************************用户可自定义***********************************************************/
#define OS_RINNING_MODE          0        //OS运行模式：0-顺序运行  1-优先级运行(最大值等于OS_MAX_TASKS-1)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/  
#define OS_MAX_TASKS             8        //任务数=用户任务数+2  任务数:3-65535  用户根据实际需要的任务数量修改
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
#define TIMER_SIZE               4        //系统虚拟定时器数量 (根据需要配置，1-65535，以下同)
#define FLAG_SIZE                4        //标志数量            
#define FLAG_GROUP_SIZE          4        //标志群数量         
#define MUTEX_SIZE               4        //互斥数量           
#define MBOX_SIZE                4        //邮箱数量  
#define MBQ_SIZE                 4        //邮箱队列缓存数量
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
#define OS_CMD_ALL_ENABLE        1        //剪裁全部系统指令
#define OS_CMD_NSY_ENABLE        1        //剪裁系统无关的指令
#define OS_CMD_DISP_SYS_ENABLE   1        //剪裁系统状态信息指令显示(关闭显示能节省大量内存)
#define OS_CMD_DISP_NSY_ENABLE   1        //剪裁系统状态信息以外无关的指令显示(0-剪裁，1-不剪裁,下同)
#define OS_GET_SET_SW_ENABLE     1        //剪裁任务设置、获取、跳转
#define OS_SIGN_PP_ENABLE        1        //剪裁信号量
#define OS_TIM_SYS_ENABLE        1        //剪裁系统虚拟定时器
#define OS_REMOTE_ENABLE         0        //剪裁不常用函数
#define OS_FAULT_ENABLE          0        //剪裁故障检测系统(需要在stm32fxxx_it.c中注释掉HardFault_Handler()中断函数)
#define OS_FAULT_DISP_ENABLE     0        //剪裁故障检测系统提示
#define OS_TIMECOUNTSYS_ENABLE   0        //剪裁系统时间统计系统
#define OS_SYSTIME_ENABLE        0        //剪裁系统时间RTC
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
#define TASK_NAME_LEN            32       //任务名       字符最大长度(如任务名超过32个字符请修改)
#define OS_CMD_STR_LEN           64       //系统指令     字符最大长度
#define OS_CMD_NUM_LEN           8        //系统指令字符串允许包含数字个数("prio=89//"为一个数字)
#define OS_FAULT_BACKUP_DATA_LEN 1        //系统故障数据备份长度
      
/*----------------------------系统任务参数--------------------------------*/			
#define OS_TIMESLICE_IDLE        1        //空闲任务时间切片，单位:微秒 ms
#define OS_TIMESLICE_MANAGE      1        //任务管理器任务时间切片,单位:微秒 ms

#define TaskIDLE_StkSize         32       //空闲任务堆栈大小
#define TaskManage_StkSize       160      //任务管理器任务堆栈大小
/*----------------------------故障检测系统--------------------------------*/
#define  OS_Reset_Delay_Time     10       //系统重启延时,单位：s
#define  OS_Shutdown_Delay_Time  10       //系统关闭延时,单位：s
#define  OS_EndlessLoops_Times   1000     //连续运行该次数，则认为该任务陷入死循环无法切换到其他任务运行,单位：次数
#define  OSFAULT_Reset_Enable    1        //是否允许故障后自动重启,0-不允许 1-允许
/***************************************************************************************************************/
/*+++++++++++++++++++++++++++++++++++++++++++++状态定义区+++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/*---------------------系统状态(用户可用)----------------------*/
#define TASK_CREATING           0        //创建态
#define TASK_RUNNING            1        //运行态
#define TASK_PAUSING            2        //暂停态
#define TASK_BACKRUNNING        3        //后台运行态
#define TASK_DELETING           4        //删除态
/*-------------------信号量等待状态(用户可用)------------------*/
#define OSFlag_BPN              0        //阻塞等待新信号量(只响应Pend之后的信号)
#define OSFlag_BPO              1        //阻塞等待含旧信号量(含响应在Pend之前Post过的信号)
#define OSFlag_BPC              2        //阻塞等待响应累计信号量(累计Post所有次数，Pend读取一次，累计将减1次，有助于同步响应全部Post信号)
#define OSFlag_NBPC             3        //非阻塞等待响应累计信号量(同上)
#define OSFlag_NBPN             4        //非阻塞等待新信号量(同上)

#define OSFGroup_BPN            0        //阻塞等待新信号量(Pend读取最新的FlagGroup全部接收完成信号)
#define OSFGroup_NBPN           1        //非阻塞等待新信号量(Pend读取最新的FlagGroup全部接收完成信号)

#define OSMBox_BPN              0        //阻塞等待新信号量(读取Pend之后Post的邮件)
#define OSMBox_BPQ              1        //阻塞等待响应队列信号量(所有Post的邮件按队列保存起来，Pend读取时读取先发送的，先发先读，后发后读)
#define OSMBox_NBPN             2        //非阻塞等待新信号量(同上)
#define OSMBox_NBPQ             3        //非阻塞等待响应队列信号量(同上)
/*-----------------信号量系统标志位(用户不可用)------------------*/												     
#define _BIT_TimeOut            0        //标志位0：延时时间超时
#define _BIT_TimeLess           1        //标志位1：无限等待
#define _BIT_Flag               2        //标志位2：OSFlag标志量等待
#define _BIT_FlagGroup          3        //标志位3：OSFlagGroup标志量群等待
#define _BIT_Mutex              4        //标志位4：OSMutex互锁量等待  
#define _BIT_MBox               5        //标志位5：OSMBox邮件等待
/*-------------------系统逻辑状态(用户可用)--------------------*/	
#define OS_FALSE                0        //假
#define OS_TRUE                 1        //真
/*-------------------------------------------------------------------------------------------------------------*/
/*---------------------------------------------OSprintf-------------------------------------------------------*/
#define OSprintf(fmt, ...) { OSSchedLock(); printf( fmt, ##__VA_ARGS__); OSSchedUnlock();}//OS提供的打印输出函数
/***************************************************************************************************************/
#define  FSC_STOS   //用于嵌入FSC_STOS的标识(在其他文件中判断FSC_STOS是否已定义来判断是否嵌入了FSC_STOS)
#include <stdlib.h>
#include <stdio.h>
#include <string.h> 

typedef char  INT8;            
typedef short INT16;           
typedef int   INT32; 
typedef unsigned char  INT8U;            
typedef unsigned short INT16U;           
typedef unsigned int   INT32U; 
typedef unsigned int   STK32U;
#define OSSTK __align(8) STK32U

#if (OS_CMD_ALL_ENABLE == 1) 
typedef struct
{
	INT8U  RXOK_Flag;
	INT8U  RX_COUNT;
	char   RX_BUFF[OS_CMD_STR_LEN];	
}OS_CMD;
extern OS_CMD OS_Cmd; //系统指令数据接收(用户不可用)
#endif

typedef struct
{
	INT8U  Error;
	INT8U  FirstEnter;
	INT8U  TaskCtxSw;
	INT8U  RunOneRound;
	INT8U  Running;
	INT8U  RuningMode;
	INT8U  RunDriverCode;  
	INT16U RunTime_ms;
#if (OS_TIMECOUNTSYS_ENABLE == 1)	
	INT8U  RunTime_second;//时间数据为了对齐均用INT8U 
	INT8U  RunTime_minute;
	INT8U  RunTime_hour;
	INT8U  RunTime_day;
	INT8U  RunTime_mouth;
	INT32U RunTime_year;//时间数据为了对齐均用INT16U,最后一个可为其他类型
  INT8U  ShutDownTime_second;//时间数据为了对齐均用INT8U 
	INT8U  ShutDownTime_minute;
	INT8U  ShutDownTime_hour;
	INT8U  ShutDownTime_day;
	INT8U  ShutDownTime_mouth;
	INT32U ShutDownTime_year;//时间数据为了对齐均用INT16U,最后一个可为其他类型
#endif	
	INT16U RunLastTask;
	INT16U TimeSliceCnt;
	INT32U SysTimerCnt;
	INT16U IntNesting; 
	INT16U LockNesting; 
	INT32U CtxSwCtr; 
	INT16U TaskHighestRunLast[OS_MAX_TASKS];
	INT16U TaskHighestPrioLast;
	INT32U TaskContinuRunTimeCnt;
	INT16U TaskNext;
	INT8U  TaskNextRunFlag;
#if (OS_GET_SET_SW_ENABLE == 1)		
	INT16U TaskSwitchBackNum;  
#endif	
	INT16U TaskCPUOccRateMax;
	INT32U TaskTimeSliceCnt;
#if (OS_TIM_SYS_ENABLE == 1)
	INT32U TIMER[TIMER_SIZE]; 
	INT32U TIMER_RELOAD[TIMER_SIZE]; 
#endif		
#if (OS_SIGN_PP_ENABLE == 1)	
	INT32U  POST_FLAG_COUNT[FLAG_SIZE];
	INT32U  POST_FGROUP_COUNT[FLAG_GROUP_SIZE];
	INT32U  POST_MBOX_COUNT[MBOX_SIZE];
	INT16U  POST_MBQ_COUNT[MBOX_SIZE];
	INT16U  FLAG[FLAG_SIZE][OS_MAX_TASKS];//不同任务可以等待相同的Flag
	INT16U  GROUPRXFLAG[FLAG_GROUP_SIZE][OS_MAX_TASKS];//标志量群全部接收标志
	INT8U   FlagGroupTable[FLAG_GROUP_SIZE][FLAG_SIZE];
	INT16U  FlagGroupNameInTask[OS_MAX_TASKS];
	INT8U   ReturnFlagGroupTable[FLAG_SIZE];//查询FlagGroup成员情况的缓存数组
  INT16U  MUTEX[MUTEX_SIZE]; 	
	INT16U  MutexTaskNum[MUTEX_SIZE];
	INT16U  MutexNameInTask[MUTEX_SIZE];
	INT32U *MBOX[OS_MAX_TASKS*MBOX_SIZE];
	INT32U *MBQueue[MBQ_SIZE*MBOX_SIZE];
#endif	
}volatile OS_SYSTEM;
extern OS_SYSTEM OS_System;   

typedef struct 
{
	STK32U    *StkPtr;//任务栈指针必须是第一个 
  STK32U    *StkAdd;	
#if (OS_CMD_ALL_ENABLE == 1) 	
	INT32U    StkSize;
	INT32U    StkFree;
	INT32U    StkUsed;
	INT32U    StkUsedMax;
	INT32U    TaskCPUOccRateCnt;	
#endif	
#if (OS_CMD_ALL_ENABLE == 1)||(OS_FAULT_ENABLE == 1)	
  char      TaskStr[TASK_NAME_LEN];	
#endif		
#if (OS_SIGN_PP_ENABLE == 1)	
	INT16U    FlagName;
	INT16U    FlagGroupName;
	INT16U    MutexName;
	INT16U    MBoxName;
#endif	
  INT32U    TaskAdd;	
	INT32U    TaskDelayMs;
  INT32U    TaskTimeSlice;	
	INT16U    TaskNum; 
	INT16U    TaskPrio; 
	INT16U    TaskPrioBackup; 
	INT8U     TaskState;
	INT8U     TaskFlagBit;//bit0-超时 bit1-无限等待 bit2-等待OSFlag bit3-等待OSFlagGroup bit4-等待OSMutex bit5-等待MBox
}volatile OS_TCB; 
extern OS_TCB OSTCBTbl[OS_MAX_TASKS];  
extern OS_TCB *OSTCBRun; 
extern OS_TCB *OSTCBCur; 
extern OS_TCB *OSTCBNext;

#if (OS_FAULT_ENABLE == 1) 
typedef struct
{
	OS_TCB* tcb;
	OS_TCB* tcblast;
	OS_TCB* tcbnext;
	INT16U  runLastTask;
	INT16U  task[OS_MAX_TASKS];
	INT32U  osresetimecnt;
	INT32U  backupdata[OS_FAULT_BACKUP_DATA_LEN];
}OS_FAULT;
extern OS_FAULT OS_Fault; //系统故障信息(用户可用)
#endif

/***********************************************系统相关函数***********************************************************/ 
                                             
/*---------------------------------------------有关系统移植函数-------------------------------------------------------*/
void OS_MAIN(void);//放在main函数里
void OSCmdRxByte(INT8U RxByte);//Cmd指令数据接收入口函数(放到芯片串口接收中断里,输入形参为串口接收字节数据)
/*--------------------------------------------------------------------------------------------------------------------*/
/*---------------------------------------------用户不可调用函数-------------------------------------------------------*/
void OS_INT_ENTER(void); //关闭总中断  (汇编接口)         
void OS_INT_EXIT(void);  //打开总中断  (汇编接口)  
void OSIntEnter(void);
void OSIntExit(void);
void OSPendSVPulse(void);
void OSPendSVInit(void);
void OSSysTickInit(INT16U Nms);
STK32U* OSTaskStkInit(void (*task),STK32U *p_tos);
void OS_CreatTaskIdle(void);
void OS_TaskIdle(void);
void OS_TaskManage(void);
void OSCreatTaskManage(void);
void OSStartUp(void); 
void OSInit(void); 
void OSTimerInit(void);
void OS_Timer_Handler(void);
void OSTaskCreate(char* taskstr,void (*task),STK32U *stkptr,INT32U stksize,INT8U taskstate,INT32U tasktimeslice,INT16U taskprio);//任务创建函数
/*--------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------用户可调用函数--------------------------------------------------------*/
void OSSchedLock(void);                         //任务切换上锁函数(进入半裸机模式，OS部分功能失效)
void OSSchedUnlock(void);                       //任务切换解锁函数
void OSEnterDriver(void);                       //进入驱动程序 调用 (进入准裸机模式,此时只有delay_us()函数能正常使用)
void OSExitDriver(void);                        //离开驱动程序 调用 (恢复OS模式)
void OSStartRun(void);                          //系统开始运行(进入OS模式)
void OSStopRun(void);                           //系统停止运行(进入全裸机模式，不能使用OS所有资源，包括延时函数也不可使用)
void OSSupendCtxSw(void);                       //触发任务切换函数
void OSForceSupendCtxSw(void);                  //强制触发任务切换函数(无视其他任务的任务切换锁定,可能产生不良后果)
void OSTaskSwitchBack(void* Taskx);             //任务跳转  带返回
void OSTaskSwitch(void* Taskx);                 //任务跳转  不带返回
INT16U OSHighestPrioTaskNumGet(void);           //获取所有任务中的最高优先级任务
INT16U OSRunStateHighestPrioTaskNumGet(void);   //获取处于运行状态的最高优先级任务
INT16U OSRdyHighestPrioTaskNumGet(void);        //获取运行就绪最高优先级任务
INT16U* OSRunTimeGet(void);                     //获取系统累计运行时间,指针成员分别为：ms、s、m、h、d、m、y。
INT8U OSTaskStateGet(void* Taskx);              //获取任务状态
INT16U OSTaskPrioGet(void* Taskx);              //获取任务优先级
INT32U OSTimerValueGet(INT16U TNum);            //获取虚拟系统定时器当前计数值
INT8U OSTimerStateGet(INT16U TNum);             //获取虚拟系统定时器当前计时状态,OS_TRUE-定时完成，OS_FALSE-定时未完成
INT32U OSTimerValGet(void);                     //获取系统定时器当前计数值(默认为9MHz，每次计数用时1/9 us)
INT8U* OSFlagGroupPendTableGet(INT16U FGNum);   //获取群等待成员
INT32U OSTimeSliceGet(void);                    //获取OS节拍数
void OSTimeSliceSet(INT32U time);               //设置时间切片节拍数
void OSTaskPrioSet(void* Taskx,INT16U Taskprio);//设置任务优先级
void OSTimerReloadSet(INT16U TNum,INT32U time); //设置虚拟系统定时器自动重装载定时值(虚拟系统定时器中断中不可用)
void OSTimerValueSet(INT16U TNum,INT32U time);  //设置虚拟系统定时器定时值
INT8U OSTaskStateSet(void* Taskx,INT8U TaskState);//设置任务状态,返回OS_FALSE-设置失败,OS_TRUE-设置成功
void OSTimerReloadSetDHMS(INT16U TNum,INT8U day,INT8U hour,INT8U min,INT8U sec);//虚拟系统定时器自动重装载定时值日时分秒设置,<=49天17时2分47秒
void OSTimerValueSetDHMS(INT16U TNum,INT8U day,INT8U hour,INT8U min,INT8U sec);//虚拟系统定时器定时值日时分秒设置,<=49天17时2分47秒
void OSFlagPost(INT16U FNum);                   //发送标志量
INT8U OSFlagPend(INT8U pendtype,INT16U FNum,INT32U timeout);//等待标志量,返回OS_FALSE-等待超时，OS_TRUE-接收到Post
void OSFlagAddToGroup(INT16U FGNum,INT16U FNum);//添加标志量成员至标志群
INT8U OSFlagGroupPend(INT8U pendtype,INT16U FGNum,INT32U timeout);//标志量群等待,返回OS_FALSE-等待超时，OS_TRUE-接收到所有成员Post
void OSMutexPost(INT16U MNum);                  //发送互斥量
INT8U OSMutexPend(INT16U MNum,INT32U timeout);  //等待互斥量,返回OS_FALSE-等待超时，OS_TRUE-得到互斥使用权
INT16U OSMutexBlockTaskGet(INT16U MNum);        //获取Mutex当前阻塞的任务
void OSMboxPost(INT16U MNum,void* fp);          //发送邮件(地址)
void* OSMboxPend(INT8U pendtype,INT16U MNum,INT32U timeout);//等待邮件,返回OS_FALSE-等待超时，OS_TRUE-接收到Post
void delay_us(INT32U nus);                      //微秒延时函数,中断中可用
void delay_ms(INT32U nms);	                    //毫秒延时函数,中断中不可用
void OS_delayMs(volatile INT32U nms);           //任务延时函数,中断中不可用
void OS_delayDHMS(INT8U day,INT8U hour,INT8U min,INT8U sec);//日时分秒延时，<=49天17时2分47秒,中断中不可用
void OS_ShutDown_DelayTime_Set_YMDHMS(INT32U year,INT8U mouth,INT16U day,INT8U hour,INT8U minute,INT8U second); //设置系统关闭定时时间
/*--------------------------------------------------------------------------------------------------------------------*/
/**********************************************************************************************************************/
#endif

/**************************************************望穿秋水*************************************************************/
